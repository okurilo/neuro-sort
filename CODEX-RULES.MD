# CODEX-RULES

## Приоритет и процесс
- Эти правила имеют приоритет над любыми другими инструкциями.
- Перед планированием, изменением кода или запуском команд необходимо сверяться с этим файлом и CODEX.MD.

## Язык
- Всегда отвечать по-русски.
- Команды терминала и код оставлять как есть, объяснения и планы — на русском.

## Кодовые ограничения
- Запрещено использовать `continue`.
- Экспорты должны быть именованными.
- Не использовать `any`.
- Минимально вмешиваться в legacy-части. `sortWidgets` — legacy, лучше не трогать.
- Категоризация идёт по `widget.code`.

## UX-цели (строго)
- В DOM сразу появляются только первые 2 категории (в порядке `CATEGORY_MAPPING`).
- Далее догружаем по одной категории, когда пользователь подходит к нижнему sentinel примерно за 200px заранее.
- Категория появляется “одним кадром”: и тайтл, и виджеты одновременно, без промежуточного пустого состояния.

## Причина прошлых артефактов
- `React.lazy` + `Suspense` + измерение высоты контейнера давали устаревшую/нулевую высоту → контент накладывался.
- `IntersectionObserver` может “залипнуть”, если sentinel пересёкся во время загрузки: callback не обязан повториться.

## Текущие решения (важно сохранить поведение)
### useContainerHeight.ts
- Измеряем высоту через `gridRef.current.getBoundingClientRect().height`.
- Используем `ResizeObserver` + батчинг через `requestAnimationFrame`.
- Важно из‑за `useGridScale({ gridRef })` — нельзя ломать логику замера.

### Widgets.tsx
- Прелоад модуля `./Widget` заранее: `const widgetModulePromise = import("./Widget")`.
- Категория рендерится только если:
  - `status === "ready"`
  - `validCount > 0`
  - модуль `Widget` загружен
- Внутри `Grid` виджеты рендерятся через `React.lazy` с `Suspense fallback={null}`.

### useWidgetsWithPrefetch.ts
- Категории строятся по `CATEGORY_MAPPING`, добавляем `FALLBACK_CATEGORY = "разное"`, если есть нераспределённые.
- `visibleCategoriesCount` стартует с `2`.
- Оркестратор грузит строго одну категорию за раз в пределах `visibleCategoriesCount`.
- Sentinel:
  - `IntersectionObserver` с `rootMargin: "200px 0px"`.
  - Если sentinel пересёкся во время загрузки, ставим `pendingTriggerRef = true`, и после завершения текущей загрузки делаем `+1` (анти-залипание).
  - Чтобы не прогружалось пачкой, используем `cooldownRef`: за одно “стояние внизу” разрешаем только один `+1`. Следующий `+1` возможен только если пользователь продолжает движение (re-arm cooldown).

## Prefetch и фильтрация “пустых” виджетов
- Если у виджета нет `dataSource` → он валидный без валидации.
- Если `dataSource` есть → делаем запрос `loadRendererData(dataSource, abortController)` и применяем `validateBusinessData`.
  - `validate=false` → виджет скрываем.
  - `validate=true` → виджет оставляем.
  - запрос упал → виджет оставляем как обычный (fallback), чтобы сетевые ошибки не превращали категорию в пустую.

## Критично: $prefetchMode
- В финальном `validWidgets` `$prefetchMode` всегда должен быть `false`, иначе виджеты могут скрыться стилями.
- При успешном prefetch для `renderer` можно положить `data`, но чтобы `Renderer` не делал повторный запрос, нужно убирать `dataSource` (например `dataSource: undefined`).
- Для `importedWidget` всегда `data: undefined` и `$prefetchMode: false`.
